---
title: 读重构 - 重构的原则
tags: [重构]
categories: [重构]
banner_img: /img/bg/home.webp
date: 2023-09-16 00:40:00
excerpt: 阅读一下重构的书籍 懂的什么是好代码 才能写出好代码
hide: false # 
sticky: 1 # 排序值
comment: true
---
重构与性能优化有很多相似之处:两者都需要修改代码，并且两者都不会改 变程序的整体功能。
两者的差别在于其目的:
重构是为了让代码“更容易理解，更易于修改”。这可能使程序运行得更快，也可能使程序运行得更慢。
在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护。

## 1. 何时重构

### 1.1 三次法则

“第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。”

“正如老话说的：事不过三，三则重构。”

### 1.2 预备性重构

“让添加新功能更容易”

“重构的最佳时机就在添加新功能之前。在动手添加新功能之前，我会看看现有的代码库，此时经常会发现：如果对代码结构做一点微调，我的工作会容易得多。”

> “这就好像我要往东去100公里。我不会往东一头把车开进树林，而是先往北开20公里上高速，然后再向东开100公里。后者的速度比前者要快上3倍。如果有人催着你“赶快直接去那儿”，有时你需要说：“等等，我要先看看地图，找出最快的路径。”这就是预备性重构于我的意义。
> ——Jessica Kerr”

“修复bug时的情况也是一样。在寻找问题根因时，我可能会发现：如果把3段一模一样且都会导致错误的代码合并到一处，问题修复起来会容易得多。或者，如果把某些更新数据的逻辑与查询逻辑分开，会更容易避免造成错误的逻辑纠缠。用重构改善这些情况，在同样场合再次出现同样bug的概率也会降低。”

### 1.3 帮助理解的重构

我需要先理解代码在做什么，然后才能着手修改。这段代码可能是我写的，也可能是别人写的。一旦我需要思考“这段代码到底在做什么”，我就会自问：能不能重构这段代码，令其一目了然？我可能看见了一段结构糟糕的条件逻辑，也可能希望复用一个函数，但花费了几分钟才弄懂它到底在做什么，因为它的函数命名实在是太糟糕了。这些都是重构的机会。

### 1.4 捡垃圾式重构

帮助理解的重构还有一个变体：我已经理解代码在做什么，但发现它做得不好，例如逻辑不必要地迂回复杂，或者两个函数几乎完全相同，可以用一个参数化的函数取而代之。这里有一个取舍：我不想从眼下正要完成的任务上跑题太多，但我也不想把垃圾留在原地，给将来的修改增加麻烦。如果我发现的垃圾很容易重构，我会马上重构它；如果重构需要花一些精力，我可能会拿一张便笺纸把它记下来，完成当下的任务再回来重构它。

### 1.5 有计划的重构和见机行事的重构

有时，即便团队做了日常的重构，还是会有问题在某个区域逐渐累积长大，最终需要专门花些时间来解决。但这种有计划的重构应该很少，大部分重构应该是不起眼的、见机行事的。

分离重构提交并不是毋庸置疑的原则，只有当你真的感到有益时，才值得这样做。

## 2.何时不应该重构

如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个API之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。

另一种情况是，如果重写比重构还容易，就别重构了。这是个困难的决定。如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度。决定到底应该重构还是重写，需要良好的判断力与丰富的经验，我无法给出一条简单的建议。

## 3. 重构的挑战

“重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。”

尽管重构的目的是加快开发速度，但是，仍旧很多人认为，花在重构的时间是在拖慢新功能的开发进度。“重构会拖慢进度”这种看法仍然很普遍，这可能是导致人们没有充分重构的最大阻力所在。

我们之所以重构，因为它能让我们更快——添加功能更快，修复bug更快。一定要随时记住这一点，与别人交流时也要不断强调这一点。重构应该总是由经济利益驱动。程序员、经理和客户越理解这一点，“好的设计”那条曲线就会越经常出现。

## 4. 测试

不会改变程序可观察的行为，这是重构的一个重要特征。如果仔细遵循重构手法的每个步骤，我应该不会破坏任何东西，但万一我犯了个错误怎么办？（呃，就我这个粗心大意的性格来说，请去掉“万一”两字。）人总会有出错的时候，不过只要及时发现，就不会造成大问题。既然每个重构都是很小的修改，即便真的造成了破坏，我也只需要检查最后一步的小修改——就算找不到出错的原因，只要回滚到版本控制中最后一个可用的版本就行了。

## 5. 遗留代码

尽管作者给出了答案  “每次触碰一块代码时，我会尝试把它变好一点点——至少要让营地比我到达时更干净。”

我看来依旧是无解

## 6.应该重构的坏代码

### 6.1 神秘命名

### 6.2 重复代码

### 6.3 过长函数

- 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
- 条件表达式和循环常常也是提炼的信号
- 如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环将其拆分成各自独立的任务。

### 6.4 过长参数列表

- 如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数


- 使用类可以有效地缩短参数列表


### 6.5 全局数据

全局数据的问题在于 任何地方都可以修改它，无法探测哪段代码产生了影响。

所以容易造成诡异的bug 确无法排查。比如：“我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。”

全局数据常见的形式有 **全局变量**, **类变量**,**单例**。

- 可以用函数组合成类或者函数组合成变换来限制需要对变量进行修改的代码量。

  

### 6.6 发散式变化

一旦需要修改，我们希望能够跳到系统的某一点，**每次只关心一个上下文**，这是我们在信息时代最注重要做的。比如：

一个类中 “新加入一个数据库，我必须修改这3个函数；如果新出现一种金融工具，我必须修改这4个函数。”

此时就要注意，“据库交互和金融逻辑处理是两个不同的上下文，将它们分别搬移到各自独立的模块中，能让程序变得更好”

正确的做法是将数据库模块隔离，在对金融模块进行逻辑处理。拆分的细才能衍生出好的架构：

**Model（模型）**： 数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。

**View（视图）**：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。前后端分离时前端项目就是 view 层

**Controller（控制器）**：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作。

### 6.7 霰弹式修改

如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。

可以使用 内联函数 内联类 ——把本不该分散的逻辑拽回一处

### 6.8 依恋情结

模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互

一个函数往往会用到几个模块的功能，那么它究竟该被置于何处呢？我们的原则是：判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起。

// TODO: https://www.jianshu.com/p/1f1049d0a0f4

访问者模式是一种将算法与对象结构分离的软件设计模式。


### 6.9 数据泥团

相同的字段 相同的参数 可以进行提炼

### 6.10 基本类型偏执

特征:

- 使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。

  ```js
  电话号码字符串通常以不同的格式和约定出现，而且可能包含不必要的字符、空格或分隔符。
  {
    "country_code": "1",
    "area_code": "555",
    "local_number": "1234567"
  }
  ```

- 使用常量编码信息

  ```
  例如 mqtt 连接站点分为国际站 国内站
  MQTT_INTERNATIONAL_STATION_TYPE = 1;
  尽管写了常量代表 1 是国际站，但是从常量中无法获取相关关系，单独阅读一段代码无法得知还有国内站的概念。
  正确做法：
  enum MQTTConnectStationType 
  { 
      International，
      Inland
  } 
  ```

- 使用字符串常量作为字段名在数组中使用。

  如果你发现自己正从数组中挑选数据，可运用 `以对象取代数组`

### 6.10 重复的switch

每当增加一个选择分支时，必须找到所有的switch，并逐一更新。多态给了我们对抗这种黑暗力量的武器，使我们得到更优雅的代码库

### 6.11 循环语句

管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作

### 6.12 冗赘的元素

程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。

增加数据结构要看实际情况，我们追求的是易读和简洁

### 6.13 夸夸其谈通用性

这个令我们十分敏感的坏味道，命名者是Brian Foote。当有人说“噢，我想我们总有一天需要做这事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。这么做的结果往往造成系统更难理解和维护。如果所有装置都会被用到，就值得那么做；如果用不到，就不值得。用不上的装置只会挡你的路，所以，把它搬开吧。

  如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）。不必要的委托可运用内联函数（115）和内联类（186）除掉。如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数。如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉。

  如果函数或类的唯一用户是测试用例，这就飘出了坏味道[…]

### 6.14 临时字段

有时你会看到这样的类：其内部某个字段仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使用的情况下猜测当初设置它的目的，会让你发疯。

请使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数（198）把所有和这些字段相关的代码都放进这个新家。也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。

### 6.15 过长的消息链

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。在实际代码中你看到的可能是一长串取值函数或一长串临时变量。采取这种方式，意味客户端代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。

  这时候应该使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法。理论上，你可以重构消息链上的所有对象，但这么做就会把所有中间对象都变成“中间人”。通常更好的选择是：先观察消息链最终得到的对象是用来干什么的，看看能否以提炼函数（106）把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数（198）把这个函数推入消息链。如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数
